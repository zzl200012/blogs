## LRU

* 剔除最近使用最少的数据
* 基于时间局部性的原理
* pros：
  * 大量频繁访问热点的 workload 下还算高效
  * 实现非常简单
* cons：
  * 没考虑数据的冷热程度，偶发性的访问大量冷数据会把热数据顶掉，造成缓存污染

## LFU

* 剔除当前访问频率（次数）最少的数据
* 同样基于时间局部性，不过是基于一定时间段内的统计结果，而 LRU 只是基于访问先后，所以 LFU 应该更为符合真实的情况
* pros：
  * 能避免 LRU 里周期性或偶发性操作所导致的缓存污染，即更加稳定
  * 一般情况下效率比较高
* cons：
  * 适应性不好。具体来讲就是不能及时针对数据访问规律的变化作出反馈，老的热点数据会“吃老本”，占着坑不让新的热点数据被保留，也就是「历史数据影响将来数据」的缓存污染

## CLOCK

* 一种近似 LRU 算法，亦称 NRU(not recently used)
* 相比 LRU 开销更小，但性能相似
* 具体原理略

## 改良 CLOCK

* 其实就是加上一个修改位，被修改过的数据还要 flush 到磁盘进行同步，为了避免 IO 这种数据最好后面再替换掉

## MRU&MFU

* 顾名思义，就是和 LRU 和 LFU 反着来，最常使用的数据反而剔除
* 因为违背局部性原理，所以绝大多数的 workload 表现都不太行，少数场景也许很不错（e.g. 疯狂遍历）

## LRU-K

* 核心思想就是把 LRU 中的访问一次就能加到最前面提升为 K 次 
* 多承担一个队列的维护成本，提升一定的命中率
* 可以认为是 LRU 和 LFU 的一个 tradeoff
* 实践证明 K 取 2 时命中率和适应性的平衡最好
* K 取值越大可以认为越趋近于 LFU

## 2 Queues(2Q)

* 2Q 可以认为是 LRU-2 的具体版本。其中历史队列用 FIFO 策略，缓存队列还用 LRU-1
* 缺点和 LRU-K 一致，毕竟本身就是后者的一种实现

## Multi Queue(MQ)

* 顾名思义就是 2Q 变成多个队列的版本，每个队列不同优先级
* 想到了 OS CPU 调度里的 MLFQ，本质上其实都是增加算法的适应能力
* 当然，多个队列的维护成本以及算法本身的实现难度都要考虑

## ARC

* 真正做到动态、自适应的替换算法
* 根据 workload 动态调整 LRU 和 LFU 的使用比例
* 具体先放着，后面有空再整 //TODO